* cl-duckdb (WiP)

#+begin_html
<div align="center">
  <a href="https://upload.wikimedia.org/wikipedia/commons/4/43/Pair_of_mandarin_ducks.jpg" target="_blank">
    <img alt="鴛鴦戲水" title="鴛鴦戲水" src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/43/Pair_of_mandarin_ducks.jpg/440px-Pair_of_mandarin_ducks.jpg" width="220" height="165">
  </a>
</div>
<p align="center">
  <a href="https://github.com/ak-coram/cl-duckdb/actions">
    <img alt="Build Status" src="https://github.com/ak-coram/cl-duckdb/workflows/CI/badge.svg" />
  </a>
</p>
#+end_html

This is a Common Lisp [[https://cffi.common-lisp.dev/][CFFI]] wrapper around the [[https://duckdb.org/][DuckDB]] C API.

** Dependencies

Currently the following Common Lisp implementations and operating
systems are tested via [[https://github.com/ak-coram/cl-duckdb/blob/main/.github/workflows/CI.yml][CI]] on x86-64 (some BSDs are also known to
work):

- [[https://sbcl.org/][SBCL]] (Linux, Windows, macOS)
- [[https://ccl.clozure.com/][CCL]] (Linux, macOS)
- [[https://ecl.common-lisp.dev/][ECL]] (Linux, macOS)

The following native libraries need to be installed in a location
where CFFI can find them:

- [[https://sourceware.org/libffi/][libffi]]
- [[https://duckdb.org/][DuckDB]]

** Installation

cl-duckdb can now be installed via [[https://www.quicklisp.org/][Quicklisp]] from the [[https://ultralisp.org/][Ultralisp]]
distribution:

#+begin_src lisp
  ;; Install the ultralisp distribution if you don't have it already
  (ql-dist:install-dist "http://dist.ultralisp.org/" :prompt nil)
  ;; Load cl-duckdb
  (ql:quickload :duckdb)
#+end_src

** Development setup

- Install [[https://www.quicklisp.org/][Quicklisp]]
- Clone this repository and add it as a local Quicklisp project, for
  example:

#+begin_src sh
  git clone git@github.com:ak-coram/cl-duckdb.git ~/Projects/cl-duckdb
  ln -s ~/Projects/cl-duckdb ~/quicklisp/local-projects/cl-duckdb
#+end_src

- Start your favored REPL (e.g. sbcl) and load the library using
  Quicklisp:

#+begin_src lisp
  (ql:quickload :duckdb)
#+end_src

*** Running tests

- Load the tests via Quicklisp:

#+begin_src lisp
  (ql:quickload :duckdb/test)
#+end_src

- Use [[https://asdf.common-lisp.dev/][ASDF]] or [[https://fiveam.common-lisp.dev/][FiveAM]] to run the tests:

#+begin_src lisp
  ;; Using ASDF:
  (asdf:test-system :duckdb)
  ;; Using FiveAM directly:
  (fiveam:run! :duckdb)
#+end_src

*** Running benchmarks

- Load the benchmarks via Quicklisp:

#+begin_src lisp
  (ql:quickload :duckdb/benchmark)
#+end_src

- Use [[https://asdf.common-lisp.dev/][ASDF]] or run the benchmarks directly:

#+begin_src lisp
  ;; Using ASDF:
  (asdf:test-system :duckdb/benchmark)
  ;; Running directly:
  (duckdb/benchmark:run-benchmarks)
#+end_src

** Basic usage

Please note that the API is experimental and subject to changes.

#+begin_src lisp
   ;; Use an in-memory transient database,
   ;; DDB:INITIALIZE-DEFAULT-CONNECTION is recommended for REPL sessions
   (ddb:with-transient-connection
     ;; Create a new range table containing integers
     (ddb::run "CREATE TABLE range (i INTEGER PRIMARY KEY)"
               "CREATE SEQUENCE seq_range_i START 1")

     ;; Use a prepared statement to populate the table with a 1000 values
     (ddb:with-statement (statement "INSERT INTO range VALUES (nextval('seq_range_i'))")
       (dotimes (_ 1000) (ddb:perform statement)))

     ;; Solve Project Euler Problem 9
     (let* ((euler9-query (str:concat "SELECT a.i * b.i * c.i AS solution "
                                      "FROM range AS c "
                                      "JOIN range AS b ON b.i < c.i "
                                      "JOIN range AS a ON a.i < b.i "
                                      "WHERE a.i + b.i + c.i = ? "
                                      "AND a.i * a.i + b.i * b.i = c.i * c.i"))
            (parameters '(1000))
            (results (ddb:query euler9-query parameters)))
       (format t "PE9 Solution: ~a~%" (ddb:get-result results 'solution 0))))
#+end_src

*** Appenders

#+begin_src lisp
  (ddb:initialize-default-connection) ; => #<DUCKDB::CONNECTION {100B1088F3}>

  (ddb:run "CREATE TABLE roman_numerals (i INTEGER, value TEXT)") ; => NIL
  (ddb:with-appender (appender "roman_numerals")
    (loop :for i :from 1 :below 4999
          :do (ddb:append-row appender (list i (format nil "~:@R" i))))) ; => NIL
  (ddb:get-result (ddb:query "SELECT * FROM roman_numerals WHERE i = 1848" nil)
                  'value 0) ; => "MDCCCXXXXVIII"
#+end_src

*** Querying Lisp vectors as table columns

Currently only the following element types are supported (the values
are currently copied into DuckDB data chunks internally). The vectors
should also have the same length.

| Common Lisp type   | DuckDB Type |
|--------------------+-------------|
| (unsigned-byte 8)  | UTINYINT    |
| (unsigned-byte 16) | USMALLINT   |
| (unsigned-byte 32) | UINTEGER    |
| (unsigned-byte 64) | UBIGINT     |
| (signed-byte 8)    | TINYINT     |
| (signed-byte 16)   | SMALLINT    |
| (signed-byte 32)   | INTEGER     |
| (signed-byte 64)   | BIGINT      |
| single-float       | REAL        |
| double-float       | DOUBLE      |

#+begin_src lisp
  (ddb:initialize-default-connection) ; => #<DUCKDB::CONNECTION {10074E8BE3}>

  (let ((indexes (make-array '(10) :element-type '(unsigned-byte 8)
                                   :initial-contents '(1 2 3 4 5 6 7 8 9 10)))
        (primes (make-array '(10) :element-type '(unsigned-byte 8)
                                  :initial-contents '(2 3 5 7 11 13 17 19 23 29))))
    (ddb:with-static-table ("primes" `(("i" . ,indexes)
                                       ("p" . ,primes)))
      (ddb:query "SELECT * FROM static_table('primes')" nil)))
  ;; => (("i" . #(1 2 3 4 5 6 7 8 9 10)) ("p" . #(2 3 5 7 11 13 17 19 23 29)))
#+end_src

** Type & Value conversions

| DuckDB Type | Common Lisp Type             | Note                                          |
|-------------+------------------------------+-----------------------------------------------|
| NULL        | null                         | nil (or :null for param. binding)             |
| BOOLEAN     | boolean                      | t, nil (or :true & :false for param. binding) |
| VARCHAR     | string                       |                                               |
| BLOB        | (vector (unsigned-byte 8))   |                                               |
| REAL        | single-float                 |                                               |
| DOUBLE      | double-float                 |                                               |
| DECIMAL     | ratio                        | Max width of 38                               |
| TINYINT     | integer                      |                                               |
| UTINYINT    | integer                      |                                               |
| SMALLINT    | integer                      |                                               |
| USMALLINT   | integer                      |                                               |
| INTEGER     | integer                      |                                               |
| UINTEGER    | integer                      |                                               |
| BIGINT      | integer                      |                                               |
| UBIGINT     | integer                      |                                               |
| HUGEINT     | integer                      |                                               |
| DATE        | local-time:date              |                                               |
| TIMESTAMP   | local-time:timestamp         | Microsecond precision                         |
| TIME        | local-time-duration:duration | Microsecond precision                         |
| INTERVAL    | periods:duration             | Microsecond precision                         |
| UUID        | uuid:uuid                    |                                               |
| ENUM types  | string                       |                                               |

- https://github.com/dlowe-net/local-time
- https://github.com/enaeher/local-time-duration
- https://github.com/jwiegley/periods
- https://github.com/dardoria/uuid

*** NIL as boolean FALSE vs NIL as NULL

#+begin_src lisp
  (ddb:initialize-default-connection)
  ;; => #<DUCKDB::CONNECTION {101CAC0A73}>

  ;; The boolean TRUE and FALSE values are mapped to T and NIL
  ;; respectively in Lisp, but SQL NULL is also mapped to NIL causing
  ;; some ambiguity:

  (ddb:query "SELECT TRUE AS x, FALSE AS y, NULL AS z" '())
  ;; => (("x" . #(T)) ("y" . #(NIL)) ("z" . #(NIL)))

  ;; When necessary it's possible to differentiate between FALSE and
  ;; NULL by simply using the IS NULL logical operator:

  (ddb:query "SELECT FALSE IS NOT NULL AS x, NULL IS NULL AS y" '())
  ;; => (("x" . #(T)) ("y" . #(T)))

  ;; When binding parameter values, NIL is bound as FALSE when DuckDB
  ;; can determine that the parameter type is boolean and as NULL
  ;; otherwise. This means that simple cases like the following work as
  ;; expected:

  (ddb:run "CREATE TABLE values (v BOOLEAN)"
           '("INSERT INTO values (v) VALUES (?)" (nil))) ; => NIL
  (ddb:query "SELECT v, v IS NOT NULL AS is_not_null FROM values" '())
  ;; => (("v" . #(NIL)) ("is_not_null" . #(T)))

  ;; In some cases DuckDB doesn't determine parameter types based on the
  ;; query and NIL is bound as NULL even for boolean parameters:

  (ddb:query "SELECT ?::boolean || '' IS NULL AS x" '(nil))
  ;; => (("x" . #(T)))

  ;; To differentiate between FALSE and NULL unambiguously when binding
  ;; boolean parameters, the keywords :FALSE and :NULL can be used. In
  ;; the query below the first parameter type is not determined by
  ;; DuckDB, so NIL would be bound AS NULL as seen in the similar
  ;; example directly above. The second parameter type is correctly
  ;; identified as boolean, so NIL would be bound as FALSE in this case.

  (ddb:query "SELECT ?::boolean || '' IS NOT NULL AS x, ?::boolean IS NULL AS y"
             '(:false :null)) ; => (("x" . #(T)) ("y" . #(T)))

  ;; For completeness the :TRUE keyword is also supported. When used as
  ;; a parameter value, it is equivalent to using T:

  (ddb:query "SELECT ? = ? AS x" '(:true t)) ; => (("x" . #(T)))
#+end_src

** Roadmap

- [X] Support for querying built-in general-purpose types
  - [X] NULL
  - [X] VARCHAR
  - [X] BOOLEAN
  - [X] TINYINT
  - [X] SMALLINT
  - [X] INTEGER
  - [X] BIGINT
  - [X] HUGEINT
  - [X] UTINYINT
  - [X] USMALLINT
  - [X] UINTEGER
  - [X] UBIGINT
  - [X] REAL (FLOAT)
  - [X] DOUBLE
  - [X] BLOB
  - [X] DATE
  - [X] DECIMAL(s, p)
  - [X] TIMESTAMP
  - [X] TIMESTAMP WITH TIME ZONE
  - [X] INTERVAL
  - [X] TIME
  - [X] UUID
  - [X] ENUM
- [-] Support for binding built-in general-purpose types
  - [X] NULL
  - [X] VARCHAR
  - [X] BOOLEAN
  - [X] TINYINT
  - [X] SMALLINT
  - [X] INTEGER
  - [X] BIGINT
  - [X] HUGEINT
  - [X] UTINYINT
  - [X] USMALLINT
  - [X] UINTEGER
  - [X] UBIGINT
  - [X] REAL (FLOAT)
  - [X] DOUBLE
  - [X] BLOB
  - [X] DATE
  - [X] DECIMAL(s, p)
  - [X] TIMESTAMP
  - [X] TIMESTAMP WITH TIME ZONE
  - [ ] INTERVAL
  - [X] TIME
  - [X] UUID
  - [X] ENUM
- [ ] Support for querying nested / composite types
  - [ ] List
  - [ ] Struct
  - [ ] Map
- [ ] Support for binding nested / composite types
  - [ ] List
  - [ ] Struct
  - [ ] Map
- [ ] Add support for [[https://duckdb.org/docs/api/c/table_functions][table functions]]
- [ ] Add support for [[https://duckdb.org/docs/api/c/replacement_scans][replacement scans]]
- [ ] ...

** Legal

- Released under the MIT License, same as DuckDB.
- [[https://en.wikipedia.org/wiki/File:Pair_of_mandarin_ducks.jpg][Source]] for README photo
